sources/render/fct_to_add.c:	if (w.item_hit == EMPTY || lvl > e->lvl)
sources/render/fct_to_add.c:		return (e->backgroundcolor);
sources/render/fct_to_add.c:	return (e->item[id].item_type);
sources/render/find_closest.c:	e->hit_negative = 0;
sources/render/find_closest.c:	e->hit[e->item[curr].item_type](r, e->item[curr], &t);
sources/render/find_closest.c:	if (curr > -1 && e->item[curr].isNega == 0)
sources/render/find_closest.c:	else if (e->item[curr].isNega == 1)
sources/render/find_closest.c:	//	e->hit_negative = 1;
sources/render/find_closest.c:	e->hit[e->item[last_hit].item_type](r, e->item[last_hit], &t);
sources/render/find_closest.c:		e->hit[e->item[last_hit].item_type](r, e->item[last_hit], &t);
sources/render/find_closest.c:		if (e->item[last_hit].isNega == 0 &&
sources/render/find_closest.c:			e->curr = last_hit;
sources/render/find_closest.c:	e->ncurr = last_hit;
sources/render/find_closest.c:	return (e->curr);
sources/render/find_closest.c:		if (hit[a] % 2 != 0 && e->item[id[a]].isNega == 0)
sources/render/find_closest.c:	if (e->item[nb].item_type == DISK ||
sources/render/find_closest.c:			e->item[nb].item_type == PLANE)
sources/render/find_closest.c:		if (e->item[id[a]].isNega == 1 && nb_hit[a] % 2 == 0)
sources/render/find_closest.c:	while (++i < e->nbs[ITEM])
sources/render/find_closest.c:		if (e->hit[e->item[i].item_type](r, e->item[i], &t))
sources/render/find_closest.c:	while (++i < e->nbs[ITEM])
sources/render/find_closest.c:		if (e->hit[e->item[i].item_type](r, e->item[i], &t)
sources/render/find_closest.c:	if (e->item[id].mat > e->nbs[MAT])
sources/render/find_closest.c:		m = e->mat[e->item[id].mat];
sources/render/find_normal.c:		n = sub(newstart, e->item[id].center);
sources/render/find_normal.c:		n = find_cylinder_normal(newstart, e->item[id]);
sources/render/find_normal.c:		n = find_cone_normal(newstart, e->item[id]);
sources/render/find_normal.c:	finite = dotproduct(e->item[id].dir, sub(newstart, e->item[id].center))
sources/render/find_normal.c:			/ magnitude2(e->item[id].dir);
sources/render/find_normal.c:				&& (finite <= 0.001 || finite >= e->item[id].height - 0.001)) ||
sources/render/find_normal.c:				(type == F_CONE && (finite >= e->item[id].height - 0.001)))
sources/render/find_normal.c:		n = (dotproduct(r.dir, e->item[id].dir) < 0 ? e->item[id].dir
sources/render/find_normal.c:			: opposite(e->item[id].dir));
sources/render/find_normal.c:		if ((newstart.x > e->item[id].center.x - 0.001 && newstart.x <
sources/render/find_normal.c:					e->item[id].center.x + 0.001) || (newstart.x >
sources/render/find_normal.c:					e->item[id].end.x - 0.001 && newstart.x <
sources/render/find_normal.c:					e->item[id].end.x + 0.001))
sources/render/find_normal.c:			n = (newstart.x > e->item[id].center.x + 0.001 ? newvec(1, 0, 0)
sources/render/find_normal.c:		if ((newstart.y > e->item[id].center.y - 0.001 && newstart.y <
sources/render/find_normal.c:					e->item[id].center.y + 0.001) || (newstart.y >
sources/render/find_normal.c:					e->item[id].end.y - 0.001 && newstart.y <
sources/render/find_normal.c:					e->item[id].end.y + 0.001))
sources/render/find_normal.c:			n = (newstart.y > e->item[id].center.y + 0.001 ? newvec(0, 1, 0)
sources/render/find_normal.c:			n = (newstart.z > e->item[id].center.z + 0.001 ? newvec(0, 0, 1)
sources/render/pixel.c:	e->pixel_img[CENTER][y * e->s_line[CENTER] + x * e->bpp[CENTER]
sources/render/pixel.c:	e->pixel_img[CENTER][y * e->s_line[CENTER] + x * e->bpp[CENTER]
sources/render/pixel.c:	e->pixel_img[CENTER][y * e->s_line[CENTER] + x * e->bpp[CENTER]
sources/render/pixel.c:	if (e->debug == 1)
sources/render/pixel.c:		e->pixel_img[CENTER][y * e->s_line[CENTER] + x * e->bpp[CENTER] / 8 + 2] = 255;
sources/render/pixel.c:		e->pixel_img[CENTER][y * e->s_line[CENTER] + x * e->bpp[CENTER] / 8] = 0;
sources/render/pixel.c:		e->pixel_img[CENTER][y * e->s_line[CENTER] + x * e->bpp[CENTER] / 8 + 1] = 0;
sources/render/pixel.c:	c.blue = e->pixel_img[CENTER][y * e->s_line[CENTER]
sources/render/pixel.c:		+ x * e->bpp[CENTER] / 8];
sources/render/pixel.c:	c.green = e->pixel_img[CENTER][y * e->s_line[CENTER]
sources/render/pixel.c:		+ x * e->bpp[CENTER] / 8 + 1];
sources/render/pixel.c:	c.red = e->pixel_img[CENTER][y * e->s_line[CENTER]
sources/render/pixel.c:		+ x * e->bpp[CENTER] / 8 + 2];
sources/render/ray.c:	w.c = e->backgroundcolor;
sources/render/ray.c:	w.r.start = e->cam->pos;
sources/render/ray.c:	k = e->backgroundcolor;
sources/render/ray.c:	while (++i < e->nbs[LIGHT])
sources/render/ray.c:	t_color	c[e->nbs[LIGHT]];
sources/render/ray.c:	while (++j < e->nbs[LIGHT])
sources/render/ray.c:		dist = sub(e->light[j].pos, impact);
sources/render/ray.c:		color_lambert(&c[j], lambert(lray, w.n_vec), e->light[j],
sources/render/ray.c:				mat), e->light[j]);
sources/render/ray.c:		c[j] = multiply_color(c[j], e->light[j].radius ?
sources/render/ray.c:				shadow_from_sphere(e->light[j], impact, w, e)
sources/render/ray.c:	k = e->cam->dir;
sources/render/shadow.c:	while (++k < e->nbs[ITEM])
sources/render/shadow.c:		if (e->hit[e->item[k].item_type](lightray, e->item[k], &t) && t > 0.001f &&
sources/render/shadow.c:				e->item[k].isNega == 0)
sources/render/shadow.c:			if (!(e->mat[e->item[k].mat].n))
sources/render/shadow.c:	else if (inshdw != EMPTY && e->mat[e->item[inshdw].mat].n)
sources/render/shadow.c:		*c += e->mat[e->item[inshdw].mat].transparency;
sources/render/shadow.c:	else if (inshdw != EMPTY && e->mat[e->item[inshdw].mat].n)
sources/render/shadow.c:		return (e->mat[e->item[inshdw].mat].transparency);
sources/render/tab.c:	n = e->mat[e->item[id].mat].n;
sources/render/tab.c:		n = e->mat[e->item[tab[i]].mat].n;
sources/render/textures.c:	item = e->item[w.item_hit];
sources/render/textures.c:	m = e->mat[item.mat];
sources/render/textures.c:			return (e->backgroundcolor);
sources/render/textures.c:		return (multiply_color(e->backgroundcolor, 255));
sources/render/textures_util.c:	if (!(tex->img = mlx_xpm_file_to_image(e->mlx, name, &tex->w, &tex->h)))
sources/render/threads.c:/*	if (!(e->img = mlx_new_image(e->mlx, WIN_W, WIN_H))
sources/render/threads.c:		|| !(e->pixel_img = (unsigned char*)mlx_get_data_addr(e->img, &e->bpp,
sources/render/threads.c:			&e->s_line, &e->ed)))
sources/render/threads.c:	if (!(bypass(e->pixel_img[CENTER], e->s_line[CENTER]))
sources/render/threads.c:			|| !veccmp(tmp, e->cam->pos))
sources/render/threads.c:			if ((rc = pthread_create(&e->thr[i], NULL, draw, e)))
sources/render/threads.c:			if (pthread_join(e->thr[i], NULL))
sources/render/threads.c:		e->loading = 1;
sources/render/threads.c:		mlx_put_image_to_window(e->mlx, e->win, e->img[CENTER], 0, 0);
sources/render/threads.c:		mlx_destroy_image(e->mlx, e->img[CENTER]);
sources/render/threads.c:		tmp = newvec(e->cam->pos.x, e->cam->pos.y, e->cam->pos.z);
sources/render/threads.c:	if (!(e->img[CENTER] = mlx_new_image(e->mlx, IMG_W, IMG_H))
sources/render/threads.c:		|| !(e->pixel_img[CENTER] =
sources/render/threads.c:			(unsigned char*)mlx_get_data_addr(e->img[CENTER], &e->bpp[CENTER],
sources/render/threads.c:			&e->s_line[CENTER], &e->ed[CENTER])))
sources/render/threads.c:			e->debug = (p.x == 400 && p.y == 300) ? 1 : 0;
sources/render/threads.c:	mlx_put_image_to_window(e->mlx, e->win, e->img[CENTER], 0, 0);
sources/render/threads.c:	mlx_destroy_image(e->mlx, e->img[CENTER]);
