Binary file objects/hud/ui1.o matches
sources/handle/keyhook.c:		e->key[KEY_TAB] = (e->key[KEY_TAB] == 1 ? 0 : 1);
sources/handle/keyhook.c:		e->key[KEY_SPC] = (e->key[KEY_SPC] == 1 ? 0 : 1);
sources/handle/keyhook.c:		e->loading = 0;
sources/handle/keyhook.c:		e->key[keycode] = 1;
sources/handle/keyhook.c:	e->key[keycode] = 0;
sources/handle/mousehook.c:		e->interface.onglet = 1;
sources/handle/mousehook.c:		e->interface.onglet = 2;
sources/handle/mousehook.c:		e->interface.onglet = 3;
sources/handle/mousehook.c:	e->mouse.button = button;
sources/handle/mousehook.c:	e->mouse.x = x;
sources/handle/mousehook.c:	e->mouse.y = y;
sources/handle/mousehook.c:	e->mouse.button = 0;
sources/handle/mousehook.c:	e->interface.shade.button = 0;
sources/handle/mousehook.c:	e->interface.spectrum.button = 0;
sources/handle/mousehook.c:	e->mouse.x = x;
sources/handle/mousehook.c:	e->mouse.y = y;
sources/handle/mousehook.c:	if (e->key[KEY_SPC] == 0)
sources/handle/mousehook.c:		if (e->key[KEY_TAB])
sources/handle/mousehook.c:			e->cam->dir = rotate_y(e->cam->dir, x * M_PI / 8);
sources/handle/mousehook.c:			e->cam->dir = rotate_x(e->cam->dir, y * M_PI / 8);
sources/handle/mousehook.c:	if (e->interface.shade.button == L_CLICK)
sources/handle/mousehook.c:			e->interface.shade.x = MARGE;
sources/handle/mousehook.c:			e->interface.shade.x = RIGHT_SPC - MARGE - 1;
sources/handle/mousehook.c:			e->interface.shade.x = x - IMG_W;
sources/handle/mousehook.c:	if (e->interface.spectrum.button == L_CLICK)
sources/handle/mousehook.c:		ui1_spectrum(e->interface.spectrum.button, x, y, e);
sources/handle/move.c:	if (e->key[KEY_TAB])
sources/handle/move.c:		mlx_do_mouse_relativeon(e->win);
sources/handle/move.c:		mlx_do_mouse_relativeoff(e->win);
sources/handle/move.c:	k = (e->cam->dir.x == 0.0f && e->cam->dir.y == 1.0f
sources/handle/move.c:		&& e->cam->dir.z == 0.0f) ? newvec(0, 0, 1) : newvec(0, 1, 0);
sources/handle/move.c:	i = crossproduct(e->cam->dir, k);
sources/handle/move.c:	j = crossproduct(i, e->cam->dir);
sources/handle/move.c:	if (e->key[KEY_LEFT] || e->key[KEY_A])
sources/handle/move.c:		e->cam->pos = add(e->cam->pos, scale(50, i));
sources/handle/move.c:	if (e->key[KEY_RIGHT] || e->key[KEY_D])
sources/handle/move.c:		e->cam->pos = add(e->cam->pos, scale(-50, i));
sources/handle/move.c:	if (e->key[KEY_UP] || e->key[KEY_W])
sources/handle/move.c:		e->cam->pos = add(e->cam->pos, scale(50, j));
sources/handle/move.c:	if (e->key[KEY_DOWN] || e->key[KEY_S])
sources/handle/move.c:		e->cam->pos = add(e->cam->pos, scale(-50, j));
sources/handle/move.c:	if (e->key[KEY_Q])
sources/handle/move.c:		e->cam->dir = rotate_axis(e->cam->dir, e->j, -10);
sources/handle/move.c:	if (e->key[KEY_E])
sources/handle/move.c:		e->cam->dir = rotate_axis(e->cam->dir, e->j, 10);
sources/handle/move.c:	k = (e->cam->dir.x == 0.0f && e->cam->dir.y == 1.0f
sources/handle/move.c:		&& e->cam->dir.z == 0.0f) ? newvec(0, 0, 1) : newvec(0, 1, 0);
sources/handle/move.c:	e->i = crossproduct(e->cam->dir, k);
sources/handle/move.c:	e->j = crossproduct(e->i, e->cam->dir);
sources/hud/cursor.c:	if (e->interface.shade.x >= MARGE
sources/hud/cursor.c:			&& e->interface.shade.x < SHAD1_XE - IMG_W)
sources/hud/cursor.c:		pt = init_point(e->interface.shade.x, e->interface.shade.y);
sources/hud/cursor.c:		e->interface.spec_shade.val = color_picker(RIGHT, pt, e);
sources/hud/cursor.c:		color = e->interface.spec_shade;
sources/hud/cursor.c:		if (e->interface.shade.x < (RIGHT_SPC) / 2)
sources/hud/cursor.c:		rect = init_rect(e->interface.shade.x, e->interface.shade.y + MARGE,
sources/hud/cursor.c:		draw_rect(RIGHT, rect, e->interface.spec_shade.val, e);
sources/hud/cursor.c:	if (e->interface.spectrum.x > 0 && e->interface.spectrum.x < RIGHT_SPC
sources/hud/cursor.c:			&& e->interface.spectrum.y > 0 && e->interface.spectrum.y < IMG_H)
sources/hud/cursor.c:				pt.x = e->interface.spectrum.x + i;
sources/hud/cursor.c:				pt.y = e->interface.spectrum.y + j;
sources/hud/cursor.c:				pt.x = e->interface.spectrum.x + j;
sources/hud/cursor.c:				pt.y = e->interface.spectrum.y + i;
sources/hud/general_ui.c:	color = e->interface.onglet;
sources/hud/general_ui.c:	mlx_string_put(e->mlx, e->win, 829, 2, (color == 1 ? RED : BLACK), "1");
sources/hud/general_ui.c:	mlx_string_put(e->mlx, e->win, 895, 2, (color == 2 ? RED : BLACK), "2");
sources/hud/general_ui.c:	mlx_string_put(e->mlx, e->win, 961, 2, (color == 3 ? RED : BLACK), "3");
sources/hud/general_ui.c:	if (e->interface.onglet == 1)
sources/hud/general_ui.c:		mlx_string_put(e->mlx, e->win, 5, IMG_H + 5, BLACK, "Filters:");
sources/hud/general_ui.c:	if (e->interface.onglet == 1)
sources/hud/general_ui.c:	mlx_put_image_to_window(e->mlx, e->win, e->img[RIGHT], IMG_W, 0);
sources/hud/general_ui.c:	mlx_put_image_to_window(e->mlx, e->win, e->img[BOTTOM], 0, IMG_H);
sources/hud/general_ui.c:	mlx_destroy_image(e->mlx, e->img[RIGHT]);
sources/hud/general_ui.c:	mlx_destroy_image(e->mlx, e->img[BOTTOM]);
sources/hud/loading.c:	mlx_clear_window(e->mlx, e->win);
sources/hud/loading.c:	//if (!(load.img = mlx_new_image(e->mlx, WIN_W, WIN_H))
sources/hud/loading.c:	mlx_put_image_to_window(e->mlx, e->win, load.img, 0, 0);
sources/hud/loading.c:	//mlx_string_put(e->mlx, e->win, 450, WIN_H / 2, WHITE, "Loading ...");
sources/hud/loading.c:	//mlx_string_put(e->mlx, e->win, WIN_W / 2, WIN_H / 3, WHITE, "Loading ...");
sources/hud/loading.c:	mlx_destroy_image(e->mlx, load.img);
sources/hud/loading.c:	e->loading = 1;
sources/hud/loading.c://	mlx_clear_window(e->mlx, e->win);
sources/hud/new_image.c:	if (!(e->img[num] = mlx_new_image(e->mlx, width, height))
sources/hud/new_image.c:		|| !(e->pixel_img[num] = (unsigned char*)mlx_get_data_addr(e->img[num],
sources/hud/new_image.c:		&(e->bpp[num]), &(e->s_line[num]), &(e->ed[num]))))
sources/hud/pick_item.c:	if (e->item[nb].item_type == 1)
sources/hud/pick_item.c:	if (e->item[nb].item_type == 2)
sources/hud/pick_item.c:	if (e->item[nb].item_type == 3)
sources/hud/pick_item.c:	if (e->item[nb].item_type == 4)
sources/hud/pick_item.c:	if (e->item[nb].item_type == 5)
sources/hud/pick_item.c:	if (e->item[nb].item_type == 6)
sources/hud/pick_item.c:	if (e->item[nb].item_type == 7)
sources/hud/pick_item.c:	if (e->item[nb].item_type == 8)
sources/hud/pick_item.c:	mlx_string_put(e->mlx, e->win, IMG_W + (RIGHT_SPC) / 3, 50, BLACK, s);
sources/hud/pick_item.c:	s = ft_itoa(e->item[nb].mat);
sources/hud/pick_item.c:	mlx_string_put(e->mlx, e->win, IMG_W + (RIGHT_SPC) / 3, 100, BLACK, s);
sources/hud/pick_item.c:			mlx_pixel_put(e->mlx, e->win, tmp.x, tmp.y, BLACK);
sources/hud/pick_item.c:	mlx_string_put(e->mlx, e->win, IMG_W + 5, 50, BLACK, "Item:");
sources/hud/pick_item.c:	if (e->interface.item.button == -1)
sources/hud/pick_item.c:		mlx_string_put(e->mlx, e->win, IMG_W + (RIGHT_SPC) / 3, 50, BLACK,
sources/hud/pick_item.c:		mlx_string_put(e->mlx, e->win, IMG_W + (RIGHT_SPC) / 3, 100, BLACK,
sources/hud/pick_item.c:		item_selector(e->interface.item.button, e);
sources/hud/pick_item.c:	mlx_string_put(e->mlx, e->win, IMG_W + 5, 100, BLACK, "Mat.:");
sources/hud/pick_item.c:		r.start = e->cam->pos;
sources/hud/pick_item.c:			e->interface.item.button = nb;
sources/hud/pick_item.c:			e->interface.item.x = x;
sources/hud/pick_item.c:			e->interface.item.y = y;
sources/hud/pick_item.c:			printf("nb = %d, item_type %d, nb_mat %d, reflection %f, transparency %f, specvalue %f, specpower %f, n %f, bump %f, scale %f, color = r %f g %f b %f\n", nb, e->item[nb].item_type, e->item[nb].mat, e->mat[e->item[nb].mat].reflection, e->mat[e->item[nb].mat].transparency, e->mat[e->item[nb].mat].specvalue, e->mat[e->item[nb].mat].specpower, e->mat[e->item[nb].mat].n, e->mat[e->item[nb].mat].bump, e->mat[e->item[nb].mat].scale, e->mat[e->item[nb].mat].diffuse.red, e->mat[e->item[nb].mat].diffuse.green, e->mat[e->item[nb].mat].diffuse.blue);
sources/hud/pick_item.c:			e->interface.item.button = -1;
sources/hud/shade_bar.c:	tab[1] = e->interface.spec.val;
sources/hud/shade_bar.c:	tab[0] = e->interface.spec.val;
sources/hud/ui1.c:	if (e->interface.onglet == 1)
sources/hud/ui1.c:			e->interface.shade.button = button;
sources/hud/ui1.c:			e->interface.shade.x = x - IMG_W;
sources/hud/ui1.c:			e->interface.shade.y = SHAD1_YS;
sources/hud/ui1.c:			pt = init_point(e->interface.spectrum.x, e->interface.spectrum.y);
sources/hud/ui1.c:			e->interface.spec_shade.val = color_picker(RIGHT, pt, e);
sources/hud/ui1.c:	if (e->interface.onglet == 1)
sources/hud/ui1.c:			e->interface.spectrum.x = x - IMG_W;
sources/hud/ui1.c:			e->interface.spectrum.y = y;
sources/hud/ui1.c:			e->interface.spectrum.button = button;
sources/hud/ui1.c:			e->interface.spec.val = color_picker(RIGHT, pt, e);
sources/hud/ui1.c:			e->interface.shade.x = (RIGHT_SPC) / 2;
sources/hud/ui1.c:			e->interface.shade.y = SHAD1_YS;
sources/hud/ui1.c:			if (e->interface.spec.val != WHITE)
sources/hud/ui1.c:				e->interface.spec_shade.val = e->interface.spec.val;
sources/hud/ui1.c:	s = ft_itoa((int)(e->interface.spec_shade.argb[R]));
sources/hud/ui1.c:	mlx_string_put(e->mlx, e->win, IMG_W, IMG_H - 45, WHITE, "R:");
sources/hud/ui1.c:	mlx_string_put(e->mlx, e->win, IMG_W + 30, IMG_H - 45, WHITE, s);
sources/hud/ui1.c:	s = ft_itoa((int)(e->interface.spec_shade.argb[G]));
sources/hud/ui1.c:	mlx_string_put(e->mlx, e->win, IMG_W + (RIGHT_SPC) / 3, IMG_H - 45, WHITE,
sources/hud/ui1.c:	mlx_string_put(e->mlx, e->win, IMG_W + 30 + (RIGHT_SPC) / 3, IMG_H - 45,
sources/hud/ui1.c:	s = ft_itoa((int)(e->interface.spec_shade.argb[B]));
sources/hud/ui1.c:	mlx_string_put(e->mlx, e->win, IMG_W + 2 * (RIGHT_SPC) / 3, IMG_H - 45,
sources/hud/ui1.c:	mlx_string_put(e->mlx, e->win, IMG_W + 30 + 2 * (RIGHT_SPC) / 3,
sources/hud/ui1.c:	insert_xpm(RIGHT, pt, "resources/little-color-wheel.xpm", e);
sources/hud/util.c:	if (!(img.img = mlx_xpm_file_to_image(e->mlx, name, &img.w, &img.h))
sources/hud/util.c:		*(int *)&e->pixel_img[nb][(int)pt.x * (e->bpp[nb] / 8)
sources/hud/util.c:			+ (int)pt.y * e->s_line[nb]] = color;
sources/hud/util.c:		color = *(int *)&e->pixel_img[nb][(int)pt.x * (e->bpp[nb] / 8)
sources/hud/util.c:			+ (int)pt.y * e->s_line[nb]];
sources/parser/get_value_mat.c:	e->mat[i].diffuse = ft_getcolor(elem.attribut[j].content);
sources/parser/get_value_mat.c:	e->mat[i].diffuse2 = ft_getcolor(elem.attribut[j].content);
sources/parser/get_value_mat.c:	e->mat[i].tex.angle = ft_posatoi(elem.attribut[j].content);
sources/parser/get_value_mat.c:	e->mat[i].tex.realw = ft_posatoi(elem.attribut[j].content);
sources/parser/get_value_mat.c:	e->mat[i].tex.realh = ft_posatoi(elem.attribut[j].content);
sources/parser/get_value_mat.c:		e->mat[i].bump = ft_posatoi(elem.attribut[j].content) / 100;
sources/parser/get_value_mat.c:		if (e->mat[i].bump > 0.99)
sources/parser/get_value_mat.c:	if (e->mat[i].type <= 2 || e->mat[i].type == 5)
sources/parser/get_value_mat.c:	e->mat[i].scale = (double)atoi(elem.attribut[j].content) / 100;
sources/parser/get_value_mat.c:	e->mat[i].specpower = ft_posatoi(elem.attribut[j].content);
sources/parser/get_value_mat.c:	e->mat[i].n = ft_posatoi(elem.attribut[j].content) / 1000;
sources/parser/get_value_mat.c:	e->mat[i].transparency = ft_posatoi(elem.attribut[j].content) / 100;
sources/parser/get_value_mat.c:	e->mat[i].reflection = ft_posatoi(elem.attribut[j].content) / 100;
sources/parser/get_value_mat.c:	e->mat[i].specvalue = ft_posatoi(elem.attribut[j].content) / 100;
sources/parser/get_value_obj.c:	e->item[i].center = ft_getpos(elem.attribut[j].content);
sources/parser/get_value_obj.c:	e->item[i].radius = ft_atoi(elem.attribut[j].content);
sources/parser/get_value_obj.c:	if (e->item[i].radius <= 0)
sources/parser/get_value_obj.c:	e->item[i].mat = ft_atoi(elem.attribut[j].content);
sources/parser/get_value_obj.c:	if (e->item[i].mat < 0 || e->item[i].mat >= nbr_mat)
sources/parser/get_value_obj.c:	e->item[i].dir = ft_getpos(elem.attribut[j].content);
sources/parser/get_value_obj.c:	if (e->item[i].dir.x == 0 && e->item[i].dir.y == 0 && e->item[i].dir.z == 0)
sources/parser/get_value_obj.c:	e->item[i].dir = normalize(e->item[i].dir);
sources/parser/get_value_obj.c:	e->item[i].d = ft_atoi(elem.attribut[j].content);
sources/parser/get_value_obj2.c:	e->item[i].angle = ft_posatoi(elem.attribut[j].content);
sources/parser/get_value_obj2.c:	if (e->item[i].angle == 0 || e->item[i].angle >= 70)
sources/parser/get_value_obj2.c:	e->item[i].height = ft_posatoi(elem.attribut[j].content);
sources/parser/get_value_obj2.c:	if (e->item[i].height == 0)
sources/parser/get_value_obj2.c:	e->item[i].center = add(e->item[i].center,\
sources/parser/get_value_obj2.c:	e->item[i].dir = rotate(e->item[i].dir, r.x, r.y, r.z);
sources/parser/get_value_obj2.c:	e->item[i].end = ft_getpos(elem.attribut[j].content);
sources/parser/get_value_obj3.c:	e->item[i].isnega = ft_posatoi(elem.attribut[j].content);
sources/parser/get_value_obj3.c:	if (e->item[i].isnega < 0 || e->item[i].isnega > 1)
sources/parser/parser_all.c:	e->cam->dir = normalize(e->cam->dir);
sources/parser/parser_all.c:	e->nbs[0] = 1;
sources/parser/parser_all.c:	while (i < e->nbs[MAT])
sources/parser/parser_all.c:		if (e->mat[i].type == 1)
sources/parser/parser_all.c:			open_texture(e, &(e->mat[i].tex), e->mat[i].path_text);
sources/parser/recup_camera.c:	e->cam->pos = ft_getpos(elem.attribut[i].content);
sources/parser/recup_camera.c:	e->cam->dir = ft_getpos(elem.attribut[i].content);
sources/parser/recup_camera.c:		e->cam->pos = add(e->cam->pos, ft_getpos(elem.attribut[i].content));
sources/parser/recup_camera.c:		e->cam->dir = rotate(e->cam->dir, r.x, r.y, r.z);
sources/parser/recup_camera.c:	if (!(e->cam = (t_cam*)malloc(sizeof(t_cam) * 1)))
sources/parser/recup_camera.c:	if (e->cam->dir.x == 0 && e->cam->dir.y == 0 && e->cam->dir.z == 0)
sources/parser/recup_light.c:	e->backgroundcolor = ft_getcolor(elem.attribut[0].content);
sources/parser/recup_light.c:		e->light[i].radius = 0;
sources/parser/recup_light.c:		e->light[i].radius = ft_posatoi(elem.attribut[j].content);
sources/parser/recup_light.c:	e->light[i].pos = ft_getpos(elem.attribut[j].content);
sources/parser/recup_light.c:	e->light[i].intensity = ft_getcolor(elem.attribut[j].content);
sources/parser/recup_light.c:	e->light[i].pos = add(e->light[i].pos, ft_getpos(elem.attribut[j].content));
sources/parser/recup_light.c:	if (!(e->light = (t_light*)malloc(sizeof(t_light) * elem.nbr_element - 1)))
sources/parser/recup_light.c:	e->nbs[2] = elem.nbr_element - 1;
sources/parser/recup_mat.c:		e->mat[i].type = 2;
sources/parser/recup_mat.c:		e->mat[i].type = 3;
sources/parser/recup_mat.c:		e->mat[i].type = 4;
sources/parser/recup_mat.c:		e->mat[i].type = 5;
sources/parser/recup_mat.c:		e->mat[i].type = 6;
sources/parser/recup_mat.c:	e->mat[i].type = 1;
sources/parser/recup_mat.c:	e->mat[i].path_text = ft_strdup(elem.attribut[j].content);
sources/parser/recup_mat.c:	e->mat[i].tex.center = newvec(0, 0, 0);
sources/parser/recup_mat.c:	e->mat[i].tex.center = ft_getpos(elem.attribut[j].content);
sources/parser/recup_mat.c:	e->mat[i].type = 0;
sources/parser/recup_mat.c:	e->mat[i].diffuse = ft_getcolor(elem.attribut[j].content);
sources/parser/recup_mat.c:	if (!(e->mat = (t_mat*)malloc(sizeof(t_mat) * elem.nbr_element)))
sources/parser/recup_mat.c:	e->nbs[1] = elem.nbr_element;
sources/parser/recup_mat.c:			if (e->mat[i].tex.angle > 360)
sources/parser/recup_mat.c:		if (e->mat[i].reflection > 100 || e->mat[i].transparency > 100 ||\
sources/parser/recup_mat.c:				e->mat[i].n > 2000)
sources/parser/recup_object.c:	if (!(e->item = (t_item*)malloc(sizeof(t_item) * elem.nbr_element)))
sources/parser/recup_object.c:	e->nbs[3] = elem.nbr_element;
sources/parser/recup_object.c:		e->item[i].isnega = 0;
sources/parser/recup_object2.c:	e->item[i].item_type = 1;
sources/parser/recup_object2.c:	e->item[i].dir = newvec(0, 0, 0);
sources/parser/recup_object2.c:	e->item[i].end = newvec(0, 0, 0);
sources/parser/recup_object2.c:	e->item[i].isnega = 0;
sources/parser/recup_object2.c:	e->item[i].d = 0;
sources/parser/recup_object2.c:	e->item[i].height = 0;
sources/parser/recup_object2.c:	e->item[i].radius = 0;
sources/parser/recup_object2.c:	e->item[i].angle = 0;
sources/parser/recup_object2.c:	e->item[i].item_type = 2;
sources/parser/recup_object2.c:	e->item[i].dir = newvec(0, 0, 0);
sources/parser/recup_object2.c:	e->item[i].end = newvec(0, 0, 0);
sources/parser/recup_object2.c:	e->item[i].d = 0;
sources/parser/recup_object2.c:	e->item[i].height = 0;
sources/parser/recup_object2.c:	e->item[i].radius = 0;
sources/parser/recup_object2.c:	e->item[i].isnega = 0;
sources/parser/recup_object2.c:	e->item[i].angle = 0;
sources/parser/recup_object2.c:	e->item[i].item_type = 4;
sources/parser/recup_object2.c:	e->item[i].dir = newvec(0, 0, 0);
sources/parser/recup_object2.c:	e->item[i].end = newvec(0, 0, 0);
sources/parser/recup_object2.c:	e->item[i].d = 0;
sources/parser/recup_object2.c:	e->item[i].height = 0;
sources/parser/recup_object2.c:	e->item[i].radius = 0;
sources/parser/recup_object2.c:	e->item[i].angle = 0;
sources/parser/recup_object2.c:	e->item[i].item_type = 3;
sources/parser/recup_object2.c:	e->item[i].dir = newvec(0, 0, 0);
sources/parser/recup_object2.c:	e->item[i].end = newvec(0, 0, 0);
sources/parser/recup_object2.c:	e->item[i].d = 0;
sources/parser/recup_object2.c:	e->item[i].height = 0;
sources/parser/recup_object2.c:	e->item[i].radius = 0;
sources/parser/recup_object2.c:	e->item[i].angle = 0;
sources/parser/recup_object2.c:	e->item[i].item_type = 5;
sources/parser/recup_object2.c:	e->item[i].dir = newvec(0, 0, 0);
sources/parser/recup_object2.c:	e->item[i].end = newvec(0, 0, 0);
sources/parser/recup_object2.c:	e->item[i].isnega = 0;
sources/parser/recup_object2.c:	e->item[i].d = 0;
sources/parser/recup_object2.c:	e->item[i].height = 0;
sources/parser/recup_object2.c:	e->item[i].radius = 0;
sources/parser/recup_object2.c:	e->item[i].angle = 0;
sources/parser/recup_object3.c:	e->item[i].item_type = 6;
sources/parser/recup_object3.c:	e->item[i].item_type = 7;
sources/parser/recup_object3.c:	e->item[i].item_type = BOX;
sources/parser/set_zero_mat.c:	e->mat[i].tex.bpp = 0;
sources/parser/set_zero_mat.c:	e->mat[i].tex.s_line = 0;
sources/parser/set_zero_mat.c:	e->mat[i].tex.ed = 0;
sources/parser/set_zero_mat.c:	e->mat[i].tex.w = 0;
sources/parser/set_zero_mat.c:	e->mat[i].tex.h = 0;
sources/parser/set_zero_mat.c:	e->mat[i].tex.realw = 0;
sources/parser/set_zero_mat.c:	e->mat[i].tex.realh = 0;
sources/parser/set_zero_mat.c:	e->mat[i].tex.angle = 0;
sources/parser/set_zero_mat.c:	e->mat[i].tex.center.x = 0;
sources/parser/set_zero_mat.c:	e->mat[i].tex.center.y = 0;
sources/parser/set_zero_mat.c:	e->mat[i].tex.center.z = 0;
sources/parser/set_zero_mat.c:	e->mat[i].tex.direction.x = 0;
sources/parser/set_zero_mat.c:	e->mat[i].tex.direction.y = 0;
sources/parser/set_zero_mat.c:	e->mat[i].tex.direction.z = 0;
sources/parser/set_zero_mat.c:	while (i < e->nbs[1])
sources/parser/set_zero_mat.c:		e->mat[i].type = 0;
sources/parser/set_zero_mat.c:		e->mat[i].path_text = NULL;
sources/parser/set_zero_mat.c:		e->mat[i].reflection = 0;
sources/parser/set_zero_mat.c:		e->mat[i].transparency = 0;
sources/parser/set_zero_mat.c:		e->mat[i].specvalue = 0;
sources/parser/set_zero_mat.c:		e->mat[i].specpower = 0;
sources/parser/set_zero_mat.c:		e->mat[i].n = 0;
sources/parser/set_zero_mat.c:		e->mat[i].bump = 0;
sources/parser/set_zero_mat.c:		e->mat[i].diffuse.red = 0;
sources/parser/set_zero_mat.c:		e->mat[i].diffuse.green = 0;
sources/parser/set_zero_mat.c:		e->mat[i].diffuse.blue = 0;
sources/parser/set_zero_mat.c:		e->mat[i].diffuse2.red = 0;
sources/parser/set_zero_mat.c:		e->mat[i].diffuse2.green = 0;
sources/parser/set_zero_mat.c:		e->mat[i].diffuse2.blue = 0;
sources/parser/set_zero_mat.c:		e->mat[i].scale = 0;
sources/render/fct_to_add.c:	if (w.item_hit == EMPTY || lvl > e->lvl)
sources/render/fct_to_add.c:		return (add_2colors(lens_flaring(w.r, e), e->backgroundcolor));
sources/render/fct_to_add.c:	return (e->item[id].item_type);
sources/render/find_closest.c:	e->ncurr = -1;
sources/render/find_closest.c:	e->hit[e->item[curr].item_type](r, e->item[curr], &t);
sources/render/find_closest.c:	if (curr > -1 && e->item[curr].isnega == 0)
sources/render/find_closest.c:	else if (e->item[curr].isnega == 1)
sources/render/find_closest.c:	e->ncurr = -1;
sources/render/find_closest.c:	e->curr = -1;
sources/render/find_closest.c:	e->hit[e->item[last_hit].item_type](r, e->item[last_hit], &t);
sources/render/find_closest.c:		e->hit[e->item[last_hit].item_type](r, e->item[last_hit], &t);
sources/render/find_closest.c:		if (e->item[last_hit].isnega == 0 &&
sources/render/find_closest.c:			e->curr = last_hit;
sources/render/find_closest.c:	e->ncurr = last_hit;
sources/render/find_closest.c:	return (e->curr);
sources/render/find_closest.c:		if (hit[a] % 2 != 0 && e->item[id[a]].isnega == 0)
sources/render/find_closest.c:	if (e->item[nb].item_type == DISK ||
sources/render/find_closest.c:			e->item[nb].item_type == PLANE)
sources/render/find_closest.c:		if (e->item[id[a]].isnega == 1 && nb_hit[a] % 2 == 0)
sources/render/find_closest.c:	while (++i < e->nbs[ITEM])
sources/render/find_closest.c:		if (e->hit[e->item[i].item_type](r, e->item[i], &t) != -1)
sources/render/find_closest.c:	while (++i < e->nbs[ITEM])
sources/render/find_closest.c:		if (e->hit[e->item[i].item_type](r, e->item[i], &t)
sources/render/find_closest.c:	if (e->item[id].mat > e->nbs[MAT])
sources/render/find_closest.c:		m = e->mat[e->item[id].mat];
sources/render/find_normal.c:		n = sub(newstart, e->item[id].center);
sources/render/find_normal.c:		n = find_cylinder_normal(newstart, e->item[id]);
sources/render/find_normal.c:		n = find_cone_normal(newstart, e->item[id]);
sources/render/find_normal.c:	if (e->ncurr > -1)
sources/render/find_normal.c:		id = e->ncurr;
sources/render/find_normal.c:	finite = dotproduct(e->item[id].dir, sub(newstart, e->item[id].center))
sources/render/find_normal.c:			/ magnitude2(e->item[id].dir);
sources/render/find_normal.c:				&& (finite <= 0.001 || finite >= e->item[id].height - 0.001)) ||
sources/render/find_normal.c:				(type == F_CONE && (finite >= e->item[id].height - 0.001)))
sources/render/find_normal.c:		n = (dotproduct(r.dir, e->item[id].dir) < 0 ? e->item[id].dir
sources/render/find_normal.c:			: opposite(e->item[id].dir));
sources/render/find_normal.c:		if ((newstart.x > e->item[id].center.x - 0.001 && newstart.x <
sources/render/find_normal.c:					e->item[id].center.x + 0.001) || (newstart.x >
sources/render/find_normal.c:					e->item[id].end.x - 0.001 && newstart.x <
sources/render/find_normal.c:					e->item[id].end.x + 0.001))
sources/render/find_normal.c:			n = (newstart.x > e->item[id].center.x + 0.001 ? newvec(1, 0, 0)
sources/render/find_normal.c:		if ((newstart.y > e->item[id].center.y - 0.001 && newstart.y <
sources/render/find_normal.c:					e->item[id].center.y + 0.001) || (newstart.y >
sources/render/find_normal.c:					e->item[id].end.y - 0.001 && newstart.y <
sources/render/find_normal.c:					e->item[id].end.y + 0.001))
sources/render/find_normal.c:			n = (newstart.y > e->item[id].center.y + 0.001 ? newvec(0, 1, 0)
sources/render/find_normal.c:			n = (newstart.z > e->item[id].center.z + 0.001 ? newvec(0, 0, 1)
sources/render/find_normal.c:	if (e->ncurr > -1)
sources/render/find_normal.c:	e->ncurr = -1;
sources/render/light.c:	while (++j < e->nbs[LIGHT])
sources/render/light.c:		dist = sub(e->light[j].pos, e->cam->pos);
sources/render/light.c:		lray.start = e->cam->pos;
sources/render/light.c:		if (in_shadow(lray, e, magnitude(sub(e->light[j].pos,
sources/render/light.c:							e->cam->pos))) != -1)
sources/render/light.c:		c = add_2colors(c, multiply_color(e->light[j].intensity,
sources/render/pixel.c:	e->pixel_img[CENTER][y * e->s_line[CENTER] + x * e->bpp[CENTER]
sources/render/pixel.c:	e->pixel_img[CENTER][y * e->s_line[CENTER] + x * e->bpp[CENTER]
sources/render/pixel.c:	e->pixel_img[CENTER][y * e->s_line[CENTER] + x * e->bpp[CENTER]
sources/render/pixel.c:	if (e->debug == 1)
sources/render/pixel.c:		e->pixel_img[CENTER][y * e->s_line[CENTER] + x * e->bpp[CENTER] / 8 + 2] = 255;
sources/render/pixel.c:		e->pixel_img[CENTER][y * e->s_line[CENTER] + x * e->bpp[CENTER] / 8] = 0;
sources/render/pixel.c:		e->pixel_img[CENTER][y * e->s_line[CENTER] + x * e->bpp[CENTER] / 8 + 1] = 0;
sources/render/pixel.c:	c.blue = e->pixel_img[CENTER][y * e->s_line[CENTER]
sources/render/pixel.c:		+ x * e->bpp[CENTER] / 8];
sources/render/pixel.c:	c.green = e->pixel_img[CENTER][y * e->s_line[CENTER]
sources/render/pixel.c:		+ x * e->bpp[CENTER] / 8 + 1];
sources/render/pixel.c:	c.red = e->pixel_img[CENTER][y * e->s_line[CENTER]
sources/render/pixel.c:		+ x * e->bpp[CENTER] / 8 + 2];
sources/render/ray.c:	w.c = e->backgroundcolor;
sources/render/ray.c:	w.r.start = e->cam->pos;
sources/render/ray.c:	if (e->filter == SEPIA)
sources/render/ray.c:	else if (e->filter == GREYSCALE)
sources/render/ray.c:	else if (e->filter == REVERSE)
sources/render/ray.c:	else if (e->filter == SATURATE)
sources/render/ray.c:	k = e->backgroundcolor;
sources/render/ray.c:	while (++i < e->nbs[LIGHT])
sources/render/ray.c:	t_color	c[e->nbs[LIGHT]];
sources/render/ray.c:	while (++j < e->nbs[LIGHT])
sources/render/ray.c:		dist = sub(e->light[j].pos, impact);
sources/render/ray.c:		color_lambert(&c[j], lambert(lray, w.n_vec), e->light[j],
sources/render/ray.c:				mat), e->light[j]);
sources/render/ray.c:		c[j] = multiply_color(c[j], e->light[j].radius ?
sources/render/ray.c:				shadow_from_sphere(e->light[j], impact, w, e)
sources/render/ray.c:	k = e->cam->dir;
sources/render/shadow.c:	while (++k < e->nbs[ITEM])
sources/render/shadow.c:		if (e->hit[e->item[k].item_type](lightray, e->item[k], &t) && t > 0.001f
sources/render/shadow.c:				&& e->item[k].isnega == 0)
sources/render/shadow.c:			if (!(e->mat[e->item[k].mat].n))
sources/render/shadow.c:	else if (inshdw != EMPTY && e->mat[e->item[inshdw].mat].n)
sources/render/shadow.c:		*c += e->mat[e->item[inshdw].mat].transparency;
sources/render/shadow.c:	else if (inshdw != EMPTY && e->mat[e->item[inshdw].mat].n)
sources/render/shadow.c:		return (e->mat[e->item[inshdw].mat].transparency);
sources/render/tab.c:	n = e->mat[e->item[id].mat].n;
sources/render/tab.c:		n = e->mat[e->item[tab[i]].mat].n;
sources/render/textures.c:	item = e->item[w.item_hit];
sources/render/textures.c:	m = e->mat[item.mat];
sources/render/textures_util.c:	if (!(tex->img = mlx_xpm_file_to_image(e->mlx, name, &tex->w, &tex->h)))
sources/render/threads.c:	if (!e->loading)
sources/render/threads.c:	else if (e->loading == 1)
sources/render/threads.c:			if ((rc = pthread_create(&e->thr[i], NULL, draw, e)))
sources/render/threads.c:			if (pthread_join(e->thr[i], NULL))
sources/render/threads.c:		if (e->cartoon == 1)
sources/render/threads.c:		mlx_put_image_to_window(e->mlx, e->win, e->img[CENTER], 0, 0);
sources/render/threads.c:		mlx_destroy_image(e->mlx, e->img[CENTER]);
sources/render/threads.c:		e->apply = 0;
sources/render/threads.c:		e->loading = 2;
sources/render/threads.c:	if (!(e->img[CENTER] = mlx_new_image(e->mlx, IMG_W, IMG_H))
sources/render/threads.c:		|| !(e->pixel_img[CENTER] =
sources/render/threads.c:			(unsigned char*)mlx_get_data_addr(e->img[CENTER], &e->bpp[CENTER],
sources/render/threads.c:			&e->s_line[CENTER], &e->ed[CENTER])))
sources/render/threads.c:			e->debug = (p.x == 400 && p.y == 300) ? 1 : 0;
sources/render/threads.c:	mlx_put_image_to_window(e->mlx, e->win, e->img[CENTER], 0, 0);
sources/render/threads.c:	mlx_destroy_image(e->mlx, e->img[CENTER]);
